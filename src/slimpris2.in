#!@PYTHON@
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, either version 3 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# Authors: terual (https://github.com/terual), Peter Oliver <git@mavit.org.uk>
#
# Heavily based on mpDris2 by Erik Karlsson <pilo@ayeon.org> and
#  Jean-Philippe Braun <eon@patapon.info>
# Some bits taken from quodlibet mpris plugin by <christoph.reiter@gmx.at>


from dbus.mainloop.glib import DBusGMainLoop
import dbus
import dbus.service
import getopt
import gettext
import gi
import inspect
import json
import logging
import math
import os
import re
import signal
import simplejson
import six
import six.moves.configparser
import six.moves.http_client
import ssl
import sys
import urllib.error
import urllib.parse
import urllib.request

gi.require_version('Soup', '2.4')
from gi.repository import GLib, Gio, Soup


gettext.bindtextdomain('slimpris2', '@datadir@/locale')
gettext.textdomain('slimpris2')
_ = gettext.gettext

identity = "Squeezebox"
params = {
    'scheme': 'http',
    'host': 'localhost',
    'port': 9000,
    'password': None,
    'progname': sys.argv[0],
    'mmkeys': True,
    'insecure_https': False,
}


# MPRIS allowed metadata tags
allowed_tags = {
    'mpris:trackid': dbus.ObjectPath,
    'mpris:length': dbus.Int64,
    'mpris:artUrl': str,
    'xesam:album': str,
    'xesam:albumArtist': list,
    'xesam:artist': list,
    'xesam:asText': str,
    'xesam:audioBPM': int,
    'xesam:comment': list,
    'xesam:composer': list,
    'xesam:contentCreated': str,
    'xesam:discNumber': int,
    'xesam:firstUsed': str,
    'xesam:genre': list,
    'xesam:lastUsed': str,
    'xesam:lyricist': str,
    'xesam:title': str,
    'xesam:trackNumber': int,
    'xesam:url': str,
    'xesam:useCount': int,
    'xesam:userRating': float,
}

# python dbus bindings don't include annotations and properties
MPRIS2_INTROSPECTION = \
    """<node name="/org/mpris/MediaPlayer2">
  <interface name="org.freedesktop.DBus.Introspectable">
    <method name="Introspect">
      <arg direction="out" name="xml_data" type="s"/>
    </method>
  </interface>
  <interface name="org.freedesktop.DBus.Properties">
    <method name="Get">
      <arg direction="in" name="interface_name" type="s"/>
      <arg direction="in" name="property_name" type="s"/>
      <arg direction="out" name="value" type="v"/>
    </method>
    <method name="GetAll">
      <arg direction="in" name="interface_name" type="s"/>
      <arg direction="out" name="properties" type="a{sv}"/>
    </method>
    <method name="Set">
      <arg direction="in" name="interface_name" type="s"/>
      <arg direction="in" name="property_name" type="s"/>
      <arg direction="in" name="value" type="v"/>
    </method>
    <signal name="PropertiesChanged">
      <arg name="interface_name" type="s"/>
      <arg name="changed_properties" type="a{sv}"/>
      <arg name="invalidated_properties" type="as"/>
    </signal>
  </interface>
  <interface name="org.mpris.MediaPlayer2">
    <method name="Raise"/>
    <method name="Quit"/>
    <annotation name="org.freedesktop.DBus.Property.EmitsChangedSignal" value="const"/>
    <property name="CanQuit" type="b" access="read"/>
    <property name="Fullscreen" type="b" access="read"/>
    <property name="CanSetFullscreen" type="b" access="read"/>
    <property name="CanRaise" type="b" access="read"/>
    <property name="HasTrackList" type="b" access="read"/>
    <property name="Identity" type="s" access="read"/>
    <property name="DesktopEntry" type="s" access="read"/>
    <property name="SupportedUriSchemes" type="as" access="read"/>
    <property name="SupportedMimeTypes" type="as" access="read"/>
  </interface>
  <interface name="org.mpris.MediaPlayer2.Player">
    <method name="Next"/>
    <method name="Previous"/>
    <method name="Pause"/>
    <method name="PlayPause"/>
    <method name="Stop"/>
    <method name="Play"/>
    <method name="Seek">
      <arg direction="in" name="Offset" type="x"/>
    </method>
    <method name="SetPosition">
      <arg direction="in" name="TrackId" type="o"/>
      <arg direction="in" name="Position" type="x"/>
    </method>
    <method name="OpenUri">
      <arg direction="in" name="Uri" type="s"/>
    </method>
    <signal name="Seeked">
      <arg name="Position" type="x"/>
    </signal>
    <property name="PlaybackStatus" type="s" access="read">
      <annotation name="org.freedesktop.DBus.Property.EmitsChangedSignal" value="true"/>
    </property>
    <property name="LoopStatus" type="s" access="readwrite">
      <annotation name="org.freedesktop.DBus.Property.EmitsChangedSignal" value="true"/>
    </property>
    <property name="Rate" type="d" access="readwrite">
      <annotation name="org.freedesktop.DBus.Property.EmitsChangedSignal" value="const"/>
    </property>
    <property name="Shuffle" type="b" access="readwrite">
      <annotation name="org.freedesktop.DBus.Property.EmitsChangedSignal" value="true"/>
    </property>
    <property name="Metadata" type="a{sv}" access="read">
      <annotation name="org.freedesktop.DBus.Property.EmitsChangedSignal" value="true"/>
    </property>
    <property name="Volume" type="d" access="readwrite">
      <annotation name="org.freedesktop.DBus.Property.EmitsChangedSignal" value="false"/>
    </property>
    <property name="Position" type="x" access="read">
      <annotation name="org.freedesktop.DBus.Property.EmitsChangedSignal" value="false"/>
    </property>
    <property name="MinimumRate" type="d" access="read">
      <annotation name="org.freedesktop.DBus.Property.EmitsChangedSignal" value="const"/>
    </property>
    <property name="MaximumRate" type="d" access="read">
      <annotation name="org.freedesktop.DBus.Property.EmitsChangedSignal" value="const"/>
    </property>
    <property name="CanGoNext" type="b" access="read">
      <annotation name="org.freedesktop.DBus.Property.EmitsChangedSignal" value="true"/>
    </property>
    <property name="CanGoPrevious" type="b" access="read">
      <annotation name="org.freedesktop.DBus.Property.EmitsChangedSignal" value="true"/>
    </property>
    <property name="CanPlay" type="b" access="read">
      <annotation name="org.freedesktop.DBus.Property.EmitsChangedSignal" value="true"/>
    </property>
    <property name="CanPause" type="b" access="read">
      <annotation name="org.freedesktop.DBus.Property.EmitsChangedSignal" value="const"/>
    </property>
    <property name="CanSeek" type="b" access="read">
      <annotation name="org.freedesktop.DBus.Property.EmitsChangedSignal" value="true"/>
    </property>
    <property name="CanControl" type="b" access="read">
      <annotation name="org.freedesktop.DBus.Property.EmitsChangedSignal" value="const"/>
    </property>
  </interface>
  <interface name="org.mpris.MediaPlayer2.TrackList">
    <property name="Tracks" type="ao" access="read">
      <annotation name="org.freedesktop.DBus.Property.EmitsChangedSignal" value="true"/>
    </property>
    <property name="CanEditTracks" type="b" access="read">
      <annotation name="org.freedesktop.DBus.Property.EmitsChangedSignal" value="true"/>
    </property>
  </interface>
</node>"""


# Wrapper to handle socket errors and similar
class SBWrapper():

    def __init__(self, params):
        self.sc = None
        self._dbus = dbus
        self._params = params
        self._monitor = False
        self._status = False
        self._position = 0
        self._dbus_service = False
        self._errors = 0
        self._retry_period = 1
        # init mmkeys, if configured
        if self._params['mmkeys']:
            try:
                gsd_object = dbus.SessionBus().get_object('org.gnome.SettingsDaemon.MediaKeys',
                                                          '/org/gnome/SettingsDaemon/MediaKeys')
                # this is what gives us the multi media keys.
                gsd_object.GrabMediaPlayerKeys('Squeezebox', 0,
                                               dbus_interface='org.gnome.SettingsDaemon.MediaKeys')
                # connect_to_signal registers our callback function.
                gsd_object.connect_to_signal(
                    'MediaPlayerKeyPressed', self.on_mediakey)
            except:
                logger.error('Failed to connect to GNOME Settings Daemon.'
                             ' Disabling multimedia key support')
                params['mmkeys'] = False

    def run(self):
        """ Try to connect to LMS """
        GLib.timeout_add_seconds(0, self.my_connect)

    def my_connect(self):
        """ Init LMS connection """
        try:
            lms.get_playing_info()

            # Export our DBUS service
            if not self._dbus_service:
                self._dbus_service = MPRISInterface()
            else:
                # Add our service to the session bus
                self._dbus_service.add_to_connection(dbus.SessionBus(),
                                                     '/org/mpris/MediaPlayer2')
                self._dbus_service.aquire_name()

            # Init internal state to throw events at start
            self.init_state()

            # Subscribe to LMS status changes
            lms.run()

            # Reset error counter
            self._errors = 0
            self._retry_period = 1
        except (
                six.moves.http_client.BadStatusLine,
                urllib.error.URLError
        ) as e:
            self._errors += 1
            if self._errors < 6:
                logger.error('Could not connect to LMS: %s' % e)
            if self._errors == 6:
                logger.info('Continue to connect but going silent')
            GLib.timeout_add_seconds(self._retry_period, self.my_connect)
            if self._retry_period < 60:
                self._retry_period = self._retry_period * 2

        # Return False to stop trying to connect
        return False

    def reconnect(self):
        logger.warning("Disconnected")
        # Release the Dbus name
        self._dbus_service.release_name()
        # Disconnect service from the session bus
        self._dbus_service.remove_from_connection()
        # Stop monitoring
        GLib.source_remove(self._monitor)
        # Clean mpd client state
        # self.disconnect()
        # Try to reconnect
        self.run()

    def init_state(self):
        # Get current state
        self._status = lms.get_playing_info()
        # Invalid some fields to throw events at start
        self._status['mode'] = 'invalid'
        if 'playlist_loop' in self._status:
            self._status['playlist_loop'][
                int(self._status['playlist_cur_index'])
            ]['title'] = 'invalid'
        self._status['playlist_cur_index'] = '-1'
        self._position = 0
        self.monitor()

    def monitor(self, status=None):
        old_status = self._status
        old_position = self._position

        self._status = status or lms.get_playing_info()

        if type(self._status) == type(dict()):

            if 'time' in self._status:
                self._position = float(self._status['time'])
            else:
                self._position = 0

            if (
                self._status['mode'] == 'play'
                and 'playlist_cur_index' in self._status
                and 'playlist_loop' in self._status
                and (
                    'playlist_cur_index' not in old_status
                    or (old_status['playlist_cur_index'] != self._status['playlist_cur_index'])
                    or (old_status['playlist_loop'][int(old_status['playlist_cur_index'])]['id'] != self._status['playlist_loop'][int(self._status['playlist_cur_index'])]['id'])
                    or (old_status['playlist_loop'][int(old_status['playlist_cur_index'])]['title'] != self._status['playlist_loop'][int(self._status['playlist_cur_index'])]['title'])
                 )
            ):
                metadata = self._dbus_service.update_property(
                    'org.mpris.MediaPlayer2.Player',
                    'Metadata'
                )
                self._dbus_service.update_property(
                    'org.mpris.MediaPlayer2.Player',
                    'CanSeek'
                )
            elif 'playlist_loop' in old_status \
                 and 'playlist_loop' not in self._status:
                metadata = self._dbus_service.update_property(
                    'org.mpris.MediaPlayer2.Player',
                    'Metadata'
                )
                self._dbus_service.update_property(
                    'org.mpris.MediaPlayer2.Player',
                    'CanSeek'
                )

            if self._status['mode'] != 'stop' and old_status['mode'] != 'stop':
                if (abs(self._position - old_position) > 2 and
                    old_status['playlist_cur_index'] == self._status['playlist_cur_index']) or \
                   old_status['playlist_cur_index'] == '-1':
                    self._dbus_service.Seeked(self._position * 1000000)

            if old_status['mixer volume'] != self._status['mixer volume']:
                self._dbus_service.update_property(
                    'org.mpris.MediaPlayer2.Player', 'Volume')

            if old_status['mode'] != self._status['mode']:
                self._dbus_service.update_property(
                    'org.mpris.MediaPlayer2.Player', 'PlaybackStatus')

            if old_status['playlist shuffle'] != self._status['playlist shuffle']:
                self._dbus_service.update_property(
                    'org.mpris.MediaPlayer2.Player', 'Shuffle')

            if old_status['playlist repeat'] != self._status['playlist repeat']:
                self._dbus_service.update_property(
                    'org.mpris.MediaPlayer2.Player', 'LoopStatus')

            if (
                bool('playlist_loop' in old_status)
                    != bool('playlist_loop' in self._status)
            ) or (
                'playlist_loop' in old_status
                and 'playlist_loop' in self._status
                and old_status['playlist_loop'] != self._status['playlist_loop']
            ):
                self._dbus_service.update_property(
                    'org.mpris.MediaPlayer2.TrackList',
                    'Tracks'
                )
                for prop in ['CanGoNext', 'CanGoPrevious', 'CanPlay']:
                    self._dbus_service.update_property(
                        'org.mpris.MediaPlayer2.Player',
                        prop
                    )
            elif (
                'playlist_cur_index' in old_status
                and 'playlist_cur_index' in self._status
            ):
                for prop in ['CanGoNext', 'CanGoPrevious']:
                    self._dbus_service.update_property(
                        'org.mpris.MediaPlayer2.Player',
                        prop
                    )

        # Return True to continue polling
        return True

    def on_mediakey(self, appname, key):
        """ GNOME media key handler """
        logger.debug('Got GNOME mmkey "%s" for "%s"' % (key, appname))
        if key == 'Play':
            if self._status['mode'] == 'play':
                lms.pause()
            else:
                lms.play()
        elif key == 'Next':
            next(lms)
        elif key == 'Previous':
            lms.prev()
        elif key == 'Stop':
            lms.stop()


class MPRISInterface(dbus.service.Object):
    ''' The base object of an MPRIS player '''

    __name = "org.mpris.MediaPlayer2.squeezebox"
    __path = "/org/mpris/MediaPlayer2"
    __introspect_interface = "org.freedesktop.DBus.Introspectable"
    __prop_interface = dbus.PROPERTIES_IFACE

    def __init__(self):
        dbus.service.Object.__init__(self, dbus.SessionBus(),
                                     MPRISInterface.__path)
        self.aquire_name()

    def aquire_name(self):
        self._bus_name = dbus.service.BusName(MPRISInterface.__name,
                                              bus=dbus.SessionBus())

    def release_name(self):
        del self._bus_name

    __root_interface = "org.mpris.MediaPlayer2"
    __root_props = {
        "CanQuit": (False, None),
        "CanRaise": (False, None),
        "Fullscreen": (False, None),
        "CanSetFullscreen": (False, None),
        "DesktopEntry": (__name, None),
        "HasTrackList": (True, None),
        "Identity": (identity, None),
        "SupportedUriSchemes": (dbus.Array(signature="s"), None),
        "SupportedMimeTypes": (dbus.Array(signature="s"), None)
    }

    def __get_playback_status():
        status = sb_wrapper._status
        return {
            'play': 'Playing',
            'pause': 'Paused',
            'stop': 'Stopped',
        }[status['mode']]

    def __set_loop_status(value):
        if str(value) == "Playlist":
            lms.set_repeat(2)
        elif str(value) == "Track":
            lms.set_repeat(1)
        elif str(value) == "None":
            lms.set_repeat(0)
        else:
            raise dbus.exceptions.DBusException("Loop mode not supported")
        return

    def __get_loop_status():
        # if lms.get_repeat() == '0':

        playlist_repeat = int(sb_wrapper._status['playlist repeat'])
        if playlist_repeat == 2:
            return "Playlist"
        elif playlist_repeat == 1:
            return "Track"
        else:
            return "None"

    def __set_shuffle(value):
        lms.set_shuffle(1 if value else 0)
        return

    def __get_shuffle():
        # if lms.get_shuffle() == '0':
        return bool(int(sb_wrapper._status['playlist shuffle']))

    def __get_metadata():
        try:
            index = int(sb_wrapper._status['playlist_cur_index'])
        except KeyError:
            return format_metadata([], "Track")
        if index >= 0:
            track = sb_wrapper._status['playlist_loop'][index]
            if 'playcount' in track:
                # Comet gives us all the data we need.
                metadata = [{k: v} for k, v in track.items()]
            else:
                # We didn't request everything we need, so get it now.
                metadata = lms.metadata(track['id'])
            return format_metadata(metadata, "Track")
        return

    def __get_volume():
        #vol = float(lms.get_volume())

        volume_percent = float(sb_wrapper._status['mixer volume'])
        if volume_percent > 0:
            return volume_percent / 100
        else:
            # Muted when negative.
            return 0.0

    def __set_volume(value):
        if value >= 0 and value <= 1:
            lms.set_volume(int(value * 100))
        return

    def __get_position():
        try:
            # position = lms.get_position()
            position = sb_wrapper._status['time']
        except KeyError:
            position = 0
        return dbus.Int64(int(position * 1000000))

    def __can_go_next():
        status = sb_wrapper._status  # lms.get_playing_info()
        if 'playlist_cur_index' in status and 'playlist_tracks' in status:
            if int(status['playlist_cur_index']) < int(status['playlist_tracks'] - 1):
                return True
        return False

    def __can_go_previous():
        if 'playlist_cur_index' in sb_wrapper._status and \
           int(sb_wrapper._status['playlist_cur_index']) > 0:
            return True
        else:
            return False

    def __can_play():
        if sb_wrapper._status['playlist_tracks'] > 0:
            return True
        else:
            return False

    def __can_seek():
        status = sb_wrapper._status  # lms.get_playing_info()
        if 'can_seek' in status:
            if status['can_seek'] == 1:
                return True
        return False

    __player_interface = "org.mpris.MediaPlayer2.Player"
    __player_props = {
        "PlaybackStatus": (__get_playback_status, None),
        "LoopStatus": (__get_loop_status, __set_loop_status),
        "Rate": (1.0, None),
        "Shuffle": (__get_shuffle, __set_shuffle),
        "Metadata": (__get_metadata, None),
        "Volume": (__get_volume, __set_volume),
        "Position": (__get_position, None),
        "MinimumRate": (1.0, None),
        "MaximumRate": (1.0, None),
        "CanGoNext": (__can_go_next, None),
        "CanGoPrevious": (__can_go_previous, None),
        "CanPlay": (__can_play, None),
        "CanPause": (True, None),
        "CanSeek": (__can_seek, None),
        "CanControl": (True, None),
    }

    def __get_tracklist():
        status = sb_wrapper._status
        tracklist = []
        if 'playlist_loop' in status:
            for track in status['playlist_loop']:
                tracklist.append(
                    dbus.ObjectPath(
                        "/org/mpris/MediaPlayer2/TrackList/%s"
                        % dbus_encode_id(track['id'])
                    )
                )
        return dbus.Array(tracklist, signature="o")

    __tracklist_interface = "org.mpris.MediaPlayer2.TrackList"
    __tracklist_props = {
        "Tracks": (__get_tracklist, None),
        "CanEditTracks": (False, None),
    }

    __prop_mapping = {
        __tracklist_interface: __tracklist_props,
        __player_interface: __player_props,
        __root_interface: __root_props}

    @dbus.service.method(__introspect_interface)
    def Introspect(self):
        return MPRIS2_INTROSPECTION

    @dbus.service.signal(__prop_interface, signature="sa{sv}as")
    def PropertiesChanged(self, interface, changed_properties,
                          invalidated_properties):
        pass

    @dbus.service.method(__prop_interface,
                         in_signature="ss", out_signature="v")
    def Get(self, interface, prop):
        getter, setter = self.__prop_mapping[interface][prop]
        if callable(getter):
            return getter()
        return getter

    @dbus.service.method(__prop_interface,
                         in_signature="ssv", out_signature="")
    def Set(self, interface, prop, value):
        getter, setter = self.__prop_mapping[interface][prop]
        if setter is not None:
            setter(value)

    @dbus.service.method(__prop_interface,
                         in_signature="s", out_signature="a{sv}")
    def GetAll(self, interface):
        read_props = {}
        props = self.__prop_mapping[interface]
        for key, (getter, setter) in six.iteritems(props):
            if callable(getter):
                getter = getter()
            read_props[key] = getter
        return read_props

    def update_property(self, interface, prop):
        getter, setter = self.__prop_mapping[interface][prop]
        if callable(getter):
            value = getter()
        else:
            value = getter
        logger.debug('Updated property: %s = %s' % (prop, value))
        self.PropertiesChanged(interface, {prop: value}, [])
        return value

    # Root methods
    @dbus.service.method(__root_interface, in_signature='', out_signature='')
    def Raise(self):
        return

    @dbus.service.method(__root_interface, in_signature='', out_signature='')
    def Quit(self):
        return

    # Player methods
    @dbus.service.method(__player_interface, in_signature='', out_signature='')
    def Next(self):
        next(lms)
        return

    @dbus.service.method(__player_interface, in_signature='', out_signature='')
    def Previous(self):
        lms.prev()
        return

    @dbus.service.method(__player_interface, in_signature='', out_signature='')
    def Pause(self):
        status = lms.get_mode()
        if status == 'play':
            lms.pause()
        return

    @dbus.service.method(__player_interface, in_signature='', out_signature='')
    def PlayPause(self):
        status = lms.get_mode()
        if status == 'play':
            lms.pause()
        else:
            lms.play()
        return

    @dbus.service.method(__player_interface, in_signature='', out_signature='')
    def Stop(self):
        lms.stop()
        return

    @dbus.service.method(__player_interface, in_signature='', out_signature='')
    def Play(self):
        lms.play()
        return

    @dbus.service.method(__player_interface, in_signature='x', out_signature='')
    def Seek(self, offset):
        status = sb_wrapper._status  # lms.get_playing_info()
        current = float(status['time'])
        end = float(status['duration'])
        offset = float(offset) / 1000000
        if current + offset <= end:
            position = current + offset
            if position < 0:
                position = 0
            lms.set_position(position)
            self.Seeked(position * 1000000)
        return

    @dbus.service.method(__player_interface, in_signature='ox', out_signature='')
    def SetPosition(self, trackid, position):
        song = sb_wrapper._status  # lms.get_playing_info()
        if trackid != dbus.ObjectPath(
                '/org/mpris/MediaPlayer2/Track/%s'
                % dbus_encode_id(song['id'])
        ):
            return
        # Convert position to seconds
        position = float(position) / 1000000
        logger.debug("SetPosition: %i, %i" % (position, int(song['time'])))
        if position <= int(song['time']):
            lms.set_position(position)
            self.Seeked(int(position * 1000000))
        return

    @dbus.service.signal(__player_interface, signature='x')
    def Seeked(self, position):
        logger.debug("Seeked to %i" % position)
        return dbus.Int64(position)

    @dbus.service.method(__player_interface, in_signature='s', out_signature='')
    def OpenUri(self, uri):
        lms.playlist_add(uri)
        lms.play()
        return

    # Tracklist methods
    @dbus.service.method(__tracklist_interface, in_signature='ao', out_signature='aa{sv}')
    def GetTracksMetadata(self, track_ids):
        metadata = []
        for track_id in track_ids:
            track_id = dbus_decode_id(str(track_id).replace(
                '/org/mpris/MediaPlayer2/TrackList/', ''))
            metadata.append(
                format_metadata(lms.metadata(track_id), "TrackList")
            )
        return dbus.Array(metadata, signature="a{sv}")

    # @dbus.service.method(__tracklist_interface, in_signature='sob', out_signature='')
    # def AddTrack(self, uri, after_track, set_as_current):
    #     return

    @dbus.service.method(__tracklist_interface, in_signature='o', out_signature='')
    def RemoveTrack(self, track_id):
        track_id = dbus_decode_id(str(track_id).replace(
            '/org/mpris/MediaPlayer2/TrackList/', ''))
        for track in sb_wrapper._status['playlist_loop']:
            if int(track['id']) == track_id:
                lms.playlist_remove(int(track['playlist index']))
        return

    @dbus.service.method(__tracklist_interface, in_signature='o', out_signature='')
    def GoTo(self, track_id):
        track_id = dbus_decode_id(str(track_id).replace(
            '/org/mpris/MediaPlayer2/TrackList/', ''))
        for track in sb_wrapper._status['playlist_loop']:
            if int(track['id']) == track_id:
                lms.playlist_goto(int(track['playlist index']))
        return

    @dbus.service.signal(__tracklist_interface, signature='ao')
    def TrackListReplaced(self, tracklist):
        logger.debug("Tracklist replaced: %s", tracklist)
        return tracklist

# Handle signals more gracefully


def handle_sigint(signum, frame):
    logger.debug(f'{signal.strsignal(signum)}.  Disconnecting.')
    lms.disconnect()


def dbus_encode_id(track_id):
    return str(track_id).replace('-', '_')


def dbus_decode_id(string):
    return int(string.replace('_', '-'))


def format_metadata(data, context):
    """http://xmms2.org/wiki/MPRIS_Metadata"""

    metadata = {}

    for item in data:
        for key in item:
            metadata[key] = item[key]

    if 'id' in metadata:
        metadata['mpris:trackid'] = dbus.ObjectPath(
            "/org/mpris/MediaPlayer2/%s/%s" %
            (context, dbus_encode_id(metadata['id']))
        )

    if 'duration' in metadata:
        metadata['mpris:length'] = float(metadata['duration']) * 1000000

    if 'year' in metadata:
        if not int(metadata['year']) == 0:
            metadata['xesam:contentCreated'] = metadata['year']

    if 'tracknum' in metadata:
        metadata['xesam:trackNumber'] = metadata['tracknum']

    if 'disc' in metadata:
        metadata['xesam:discNumber'] = int(re.match('^([0-9]+).*',
                                                    metadata['disc']).group(1))

    if 'playcount' in metadata:
        metadata['xesam:useCount'] = metadata['playcount']

    if 'bpm' in metadata:
        metadata['xesam:audioBPM'] = metadata['bpm']

    if 'lyrics' in metadata:
        metadata['xesam:asText'] = metadata['lyrics']

    for tag in ('album', 'title', 'url'):
        if tag in metadata:
            metadata['xesam:%s' % tag] = metadata[tag]

    for tag in ('artist', 'comment', 'composer', 'genre'):
        if tag in metadata:
            metadata['xesam:%s' % tag] = [metadata[tag]]

    if 'artwork_url' in metadata:
        # Work around for https://gitlab.gnome.org/GNOME/gvfs/issues/54
        artwork_url = re.sub(r'(?i)%2f', '/', metadata['artwork_url'])

        metadata['mpris:artUrl'] = lms.get_absolute_url(artwork_url)
    elif 'coverart' in metadata and 'coverid' in metadata:
        if int(metadata['coverart']) == 1:
            metadata['mpris:artUrl'] = lms.get_coverart_url(metadata['coverid'])

    # Stream: populate some missings tags with stream's name
    if 'name' in metadata:
        if 'xesam:title' not in metadata:
            metadata['xesam:title'] = metadata['name']
        elif 'xesam:album' not in metadata:
            metadata['xesam:album'] = metadata['name']

    surplus_tags = set(metadata.keys()).difference(set(allowed_tags.keys()))
    # Remove surplus tags
    for tag in surplus_tags:
        del metadata[tag]

    # Cast metadata to the correct type, or discard it
    for key, value in list(metadata.items()):
        try:
            metadata[key] = allowed_tags[key](value)
        except ValueError:
            del metadata[key]
            logger.error("Can't cast value %s to %s" %
                         (value, allowed_tags[key]))

    return dbus.Dictionary(metadata, signature='sv')


class LMSConnection:

    def get_coverart_url(self, track_id, size=None):
        if size:
            return self.get_absolute_url(
                "/music/%s/cover_%sx%s_o" % (track_id, size, size)
            )
        else:
            return self.get_absolute_url(
                "/music/%s/cover.jpg" % (track_id)
            )

    def get_absolute_url(self, relative_url):
        if urllib.parse.urlparse(relative_url).scheme == '':
            if relative_url[0] != '/':
                relative_url = '/' + relative_url
            return "%s://%s:%s%s" % (
                self.scheme, self.host, self.port, relative_url
            )
        else:
            return relative_url

    def get_playing_info(self):
        #{'signalstrength': 0, 'mixer volume': 100, 'player_name': 'Studeerkamer', 'playlist mode': 'off', 'power': 1, 'playlist repeat': 0, 'player_ip': '192.168.1.58:49078', 'playlist_timestamp': 1338368677.0128, 'playlist_cur_index': '0', 'playlist shuffle': 0, 'rate': 1, 'seq_no': 0, 'mode': 'play', 'time': 161.490672870636, 'duration': 314.232, 'can_seek': 1, 'playlist_tracks': 12, 'player_connected': 1}
        info = self.query(self.player_id, "status", "0", None, "tags:")
        return info or {"mode": "invalid"}

    def metadata(self, track_id):
        #path = self.get_track_path()
        songinfo = self.query(
            self.player_id, "songinfo", "0", None,
            "tags:acdgijkKlmOtuwy",
            "track_id:%s" % track_id
        )

        return songinfo['songinfo_loop']

    def get_track_path(self):
        return self.query(self.player_id, "path", "?")['_path']

    def get_track_id(self, path):
        return self.query(self.player_id, "songinfo", "0", "1", "url:%s" % path)['songinfo_loop'][0]['id']

    def get_track_title(self):
        return self.query(self.player_id, "title", "?")['_title']

    def get_track_artist(self):
        return self.query(self.player_id, "artist", "?")['_artist']

    def get_track_album(self):
        return self.query(self.player_id, "album", "?")['_album']

    def get_track_duration(self):
        return self.query(self.player_id, "duration", "?")['_duration']

    def get_mode(self):
        return self.query(self.player_id, "mode", "?")['_mode']

    def play(self):
        return self.query(self.player_id, "play")

    def pause(self):
        return self.query(self.player_id, "pause")

    def stop(self):
        return self.query(self.player_id, "stop")

    def __next__(self):
        return self.query(self.player_id, "playlist", "jump", "+1")

    def prev(self):
        return self.query(self.player_id, "playlist", "jump", "-1")

    def get_volume(self):
        # Get volume (0-100)
        return float(self.query(self.player_id, "mixer", "volume", "?")['_volume'])

    def set_volume(self, volume):
        # Set volume (0-100)
        return self.query(self.player_id, "mixer", "volume", volume)

    def get_position(self):
        return float(self.query(self.player_id, "time", "?")['_time'])

    def set_position(self, pos):
        # set in seconds
        return self.query(self.player_id, "time", pos)

    def seek(self, pos):
        if pos >= 0:
            return self.query(self.player_id, "time", "+%d" % pos)
        else:
            return self.query(self.player_id, "time", "-%d" % pos)

    def set_repeat(self, num):
        # 0 no repeat, 1 repeat song, 2 repeat playlist.
        return self.query(self.player_id, "playlist", "repeat", num)

    def get_repeat(self):
        # 0 no repeat, 1 repeat song, 2 repeat playlist.
        return self.query(self.player_id, "playlist", "repeat", "?")['_repeat']

    def get_shuffle(self):
        # 0 no shuffle, 1 shuffle songs, 2 shuffle albums.
        return self.query(self.player_id, "playlist", "shuffle", "?")['_shuffle']

    def set_shuffle(self, num):
        # 0 no shuffle, 1 shuffle songs, 2 shuffle albums.
        return self.query(self.player_id, "playlist", "shuffle", num)

    def playlist_goto(self, playlist_index):
        return self.query(self.player_id, "playlist", "index", playlist_index)

    def playlist_add(self, uri):
        return self.query(self.player_id, "playlist", "add", uri)

    def playlist_remove(self, playlist_index):
        return self.query(self.player_id, "playlist", "delete", playlist_index)


class JSONConnection(LMSConnection):

    def __init__(self, params):

        self.scheme = params['scheme']
        self.host = params['host']
        self.port = params['port']
        self.username = None
        self.password = None
        if 'username' in params:
            self.username = params['username']
        if 'password' in params:
            self.password = params['password']
        self.jsonrpc_url = f"{self.scheme}://{self.host}:{self.port}/jsonrpc.js"
        self.player_id = params['mac']
        if 'insecure_https' in params:
            self.insecure_https = params['insecure_https']

        handlers = []

        if self.scheme == 'https' and self.insecure_https:
            context = ssl._create_unverified_context()
            handlers.append(urllib.request.HTTPSHandler(context=context))

        if self.username and self.password:
            auth_handler = urllib.request.HTTPBasicAuthHandler()
            auth_handler.add_password(
                realm='Logitech Media Server',
                uri=("%s://%s:%s/" % (self.scheme, self.host, self.port)),
                user=self.username,
                passwd=self.password
            )
            handlers.append(auth_handler)

        opener = urllib.request.build_opener(*handlers)
        urllib.request.install_opener(opener)

    def get_coverart_url(self, track_id, size=None):

        login = ""
        if self.username and self.password:
            login = "%s:%s@" % (self.username, self.password)

        if size:
            return "%s://%s%s:%s/music/%s/cover_%sx%s_o" % (self.scheme, login, self.host, self.port, track_id, size, size)
        else:
            return "%s://%s%s:%s/music/%s/cover.jpg" % (self.scheme, login, self.host, self.port, track_id)

    def query(self, player_id, *args):
        params = simplejson.dumps(
            {'id': 1, 'method': 'slim.request', 'params': [player_id, list(args)]})
        req = urllib.request.Request(self.jsonrpc_url, params.encode('utf8'))
        req.add_header(
            'User-Agent',
            'slimpris2/@VERSION@ Python-urllib/%d.%d' % sys.version_info[:2]
        )

        try:
            response = urllib.request.urlopen(req)
        except urllib.error.HTTPError as error:
            logger.error("%s. Query was %s", error.reason, list(args))
            return
        response_txt = response.read()
        result = simplejson.loads(response_txt)['result']
        logger.debug("query: %s, result: %s", list(args), result)
        return result


class CometConnection(JSONConnection):
    def __init__(self, params):
        super().__init__(params)

        self.comet_url = f"{self.scheme}://{self.host}:{self.port}/cometd/"
        self.comet_id = 0
        self.retry_period = 1

    def run(self):
        self.session = Soup.Session()
        self.session.props.user_agent = "slimpris2/@VERSION@ "
        if logger.isEnabledFor(logging.DEBUG):
            self.session.add_feature(
                Soup.Logger.new(Soup.LoggerLogLevel.BODY, 1024)
            )

        self.handshake()

    def get_comet_id(self):
        self.comet_id += 1
        return self.comet_id

    def handshake(self):
        self.send_comet_requests([{
            'channel': '/meta/handshake',
            'version': '1.0',
            'minimumVersion': '1.0',
            'supportedConnectionTypes': ['long-polling'],
            'id': self.get_comet_id(),
        }])
        return False

    def meta_subscribe(self):
        self.send_comet_requests([{
            'channel': '/meta/subscribe',
            'clientId': self.comet_client_id,
            'id': self.get_comet_id(),
            'subscription': f'/{self.comet_client_id}/**',
        }])
        return False

    def slim_subscribe(self):
        self.send_comet_requests([{
            'channel': '/slim/subscribe',
            'clientId': self.comet_client_id,
            'data': {
                'request': [
                    self.player_id,
                    [
                        "status",
                        "0",
                        None,
                        "tags:acdgijkKlmOtuwy",
                        "subscribe:0"
                    ],
                ],
                'response': f'/{self.comet_client_id}/slim/status/{self.player_id}',
            },
            'id': self.get_comet_id(),
        }])
        return False

    def connect(self):
        self.send_comet_requests([{
            'channel': f'/meta/connect',
            'clientId': self.comet_client_id,
            'connectionType': 'long-polling',
            'id': self.get_comet_id(),
        }])
        return False

    def disconnect(self):
        self.send_comet_requests([{
            'channel': f'/meta/disconnect',
            'clientId': self.comet_client_id,
            'id': self.get_comet_id(),
        }])
        self.comet_url = None
        GLib.timeout_add_seconds(10, loop.quit)
        return False

    def send_comet_requests(self, requests):
        message = Soup.Message.new(
            "POST",
            self.comet_url + inspect.currentframe().f_back.f_code.co_name
        )
        message.set_request(
            'application/json; charset=UTF-8',
            Soup.MemoryUse.COPY,
            json.dumps(requests).encode()
        )
        self.session.send_async(
            message, None, self.receive_comet_responses, message
        )

    def retry(self, message):
        if self.comet_url:
            self.session.send_async(
                message, None, self.receive_comet_responses, message
            )
        return False

    def receive_comet_responses(self, session, result, message):
        try:
            input_stream = session.send_finish(result)
            status_code = message.status_code
            if not (200 <= status_code and status_code < 300):
                raise HttpNonSuccessException(
                    message.status_code,
                    message.reason_phrase,
                )
        except (GLib.Error, HttpNonSuccessException) as e:
            if isinstance(e, GLib.Error) \
               and e.matches(Gio.io_error_quark(), Gio.IOErrorEnum.TIMED_OUT):
                # We expect long polling to time out eventually, so
                # retry immediately:
                retry_period = 0
            else:
                retry_period = self.retry_period
                if self.retry_period < 60:
                    self.retry_period = self.retry_period * 2
                logger.error(f"{message.get_uri().to_string(False)}: {e.code} {e.message}")
                logger.info(f"Will retry in {retry_period} seconds")
            GLib.timeout_add_seconds(retry_period, self.retry, message)
            return

        self.retry_period = 1

        # I couldn't get Gio.InputStream.read_all() to work :-(
        content, length = Gio.DataInputStream.new(input_stream) \
                                             .read_upto("\00", 1, None)
        for msg in json.loads(content):
            logger.debug(f"Received comet response: {msg}")
            if msg['channel'] == '/meta/handshake':
                if msg['successful']:
                    self.comet_client_id = msg['clientId']
                    GLib.timeout_add(0, self.meta_subscribe)
                    GLib.timeout_add(0, self.connect)
                else:
                    logger.critical(f"Handshake failed: {msg}")
                    raise CometError(msg)
            elif msg['channel'] == '/meta/subscribe':
                if msg['successful']:
                    GLib.timeout_add(0, self.slim_subscribe)
                else:
                    logger.critical(f"Subscription failed: {msg}")
                    raise CometError(msg)
            elif msg['channel'] == '/slim/subscribe':
                if not msg['successful']:
                    logger.critical(f"Subscription failed: {msg}")
                    raise CometError(msg)
            elif msg['channel'] == '/meta/connect':
                if self.comet_url:
                    GLib.timeout_add_seconds(
                        math.ceil(int(msg['advice']['interval'])/1000),
                        self.connect,
                    )
                if not msg['successful']:
                    logger.warning(f"Connection failed: {msg}")
            elif re.search(
                    f"^/{re.escape(self.comet_client_id)}/slim/status/{re.escape(self.player_id)}$",
                    msg['channel']
            ):
                sb_wrapper.monitor(msg['data'])
            elif msg['channel'] == '/meta/disconnect':
                if not msg['successful']:
                    logger.critical(f"Disconnection failed: {msg}")
                loop.quit()
            else:
                logger.warning(f"Unexpected comet response: {msg}")


class HttpNonSuccessException(Exception):
    def __init__(self, code, message):
        self.code = code
        self.message = message


# FIXME: handle these exceptions.
class CometError(Exception):
    def __init__(self, message):
        self.message = message


def usage(params):
    print("""\
Usage: %(progname)s [OPTION]... [LMS_HOST LMS_PORT PLAYER]

     -d, --debug            Run in debug mode

Default: LMS_HOST: %(host)s
         LMS_PORT: %(port)s""" % params)

if __name__ == '__main__':
    DBusGMainLoop(set_as_default=True)

    path = ""

    try:
        (opts, args) = getopt.getopt(sys.argv[
            1:], 'hdV', ['help', 'debug', 'version'])
    except getopt.GetoptError as xxx_todo_changeme:
        (msg, opt) = xxx_todo_changeme.args
        print(sys.argv[0] + ': ' + msg)
        print()
        usage(params)
        sys.exit(2)

    log_format = '%(asctime)s %(module)s %(levelname)s: %(message)s'
    log_level = logging.INFO

    for (opt, arg) in opts:
        if opt in ['-h', '--help']:
            usage(params)
            sys.exit()
        if opt in ['-V', '--version']:
            print("""slimpris2 @VERSION@

Copyright (C) 2011-2021 Peter Oliver, Bart Lauret, Jean-Philippe Braun.
This program comes with ABSOLUTELY NO WARRANTY.  This is free software,
and you are welcome to redistribute it under certain conditions.

Report bugs to https://github.com/mavit/slimpris2/issues""")
            sys.exit()
        elif opt in ['-d', '--debug']:
            log_level = logging.DEBUG

    logging.basicConfig(format=log_format, level=log_level)
    logger = logging.getLogger('slimpris2')

    config = six.moves.configparser.ConfigParser()
    config.read(['/etc/slimpris2.conf',
                 os.path.expanduser('~/.config/slimpris2/slimpris2.conf')])

    if config.has_option('Connection', 'scheme'):
        params['scheme'] = config.get('Connection', 'scheme')
    if config.has_option('Connection', 'host'):
        params['host'] = config.get('Connection', 'host')
    if config.has_option('Connection', 'port'):
        params['port'] = config.get('Connection', 'port')
    if config.has_option('Connection', 'mac'):
        params['mac'] = config.get('Connection', 'mac')
    if config.has_option('Connection', 'player'):
        params['mac'] = config.get('Connection', 'player')
    if config.has_option('Connection', 'username'):
        params['username'] = config.get('Connection', 'username')
    if config.has_option('Connection', 'password'):
        params['password'] = config.get('Connection', 'password')
    if config.has_option('Connection', 'insecure_https'):
        params['insecure_https'] = config.getboolean('Connection',
                                                     'insecure_https')

    if config.has_option('Connection', 'username') and not config.has_option('Connection', 'password'):
        logger.warning(
            "A username, '%s', is set, but there is no corresponding password", params['username'])
    elif config.has_option('Connection', 'password') and not config.has_option('Connection', 'username'):
        logger.warning(
            "A password is set, but there is no corresponding username")

    if len(args) == 3 and args[1].isdigit():
        params['host'] = args[0]
        params['port'] = int(args[1])
        params['mac'] = args[2]
    elif len(args) == 0:
        pass
    else:
        usage(params)
        sys.exit(2)

    if 'mac' not in params or params['mac'] == '':
        logger.fatal("No player name or MAC address specified either in the config file or on the command line")
        sys.exit(2)

    if re.search(r'^(?:\d\d.){5}\d\d$', params['mac']):
        params['mac'] = params['mac'].replace('-', ':')

    for bling in ['mmkeys']:
        if config.has_option('Bling', bling):
            params[bling] = config.getboolean('Bling', bling)

    loop = GLib.MainLoop()
    signal.signal(signal.SIGINT, handle_sigint)
    signal.signal(signal.SIGTERM, handle_sigint)

    # Used to communicate with LMS
    lms = CometConnection(params)

    # Create wrapper to handle connection failures with LMS more gracefully
    sb_wrapper = SBWrapper(params)
    sb_wrapper.run()

    # Run idle loop
    loop.run()
